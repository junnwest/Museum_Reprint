<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Digital Substrate Room</title>

  <style>
    html, body {
      margin:0;
      height:100%;
      background:#ffffff;
      overflow:hidden;
    }

    body {
      display:flex;
      justify-content:center;
      align-items:center;
      position:relative;
      cursor:crosshair;
    }

    #canvas {
      max-width:90vw;
      max-height:90vh;
    }

    .lens {
      position:absolute;
      width:240px;
      height:240px;
      border-radius:50%;
      border:2px solid rgba(0,0,0,0.6);
      overflow:hidden;
      pointer-events:none;
      display:flex;
      justify-content:center;
      align-items:center;
      font-family:monospace;
  font-size:14px;
  line-height:1.25em;
      padding:0; /* move padding to the text element so preview canvas fills entire lens */
      color:#00ff00; /* green binary numbers inside the lens */
      white-space:pre;
      text-align:left;
      opacity: 1;
      transition: opacity 300ms ease;
    }

    .lens canvas {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      display: block;
    }

    .lens pre { /* ensure binary text sits above preview, center lines */
      position: relative;
      z-index: 1;
      margin: 0;
      pointer-events: none;
      padding: 12px; /* keep the original padding for the text */
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      overflow: auto;
      color: inherit;
      display: flex;
      flex-direction: column;
      justify-content: center; /* vertical centering */
      align-items: center;     /* horizontal centering */
      text-align: center;
      white-space: pre; /* preserve line breaks and spaces */
    }
  </style>
</head>

<body>

<canvas id="canvas"></canvas>

<script>
  const imgSrc = "{{ url_for('static', filename='monalisa.jpg') }}";
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const img = new Image();
  img.src = imgSrc;
  img.onload = () => {
    canvas.width  = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
  };

  const LENS_SIZE = 240; // CSS pixels (matches .lens width/height)

  // draw the sampled region (sx,sy in canvas/backing-store pixels) into the lens preview canvas
  function drawLensPreview(previewCanvas, sx, sy, sampleSize) {
    if (!previewCanvas) return;
    const dpr = window.devicePixelRatio || 1;
    const ctxL = previewCanvas.getContext('2d');
    // set transform so we can draw using CSS pixels while canvas uses backing pixels
    ctxL.setTransform(dpr, 0, 0, dpr, 0, 0);
    // clear using CSS-pixel coordinates
    ctxL.clearRect(0, 0, LENS_SIZE, LENS_SIZE);
    ctxL.imageSmoothingEnabled = true;
    // draw from the main canvas (which uses canvas pixel coordinates)
    // scale the sample to fill the preview canvas (use CSS-pixel dest LENS_SIZE)
    ctxL.drawImage(canvas, sx, sy, sampleSize, sampleSize, 0, 0, LENS_SIZE, LENS_SIZE);
  }

  // create a lens element containing a preview canvas and a <pre> with the binary text
  function createLens(x, y, text, sx, sy, sampleSize) {
    const el = document.createElement("div");
    el.className = "lens";
    el.style.left = (x - LENS_SIZE/2) + "px";
    el.style.top  = (y - LENS_SIZE/2) + "px";

    // preview canvas (for magnified fragment)
    const preview = document.createElement('canvas');
    const dpr = window.devicePixelRatio || 1;
    preview.width = LENS_SIZE * dpr;
    preview.height = LENS_SIZE * dpr;
    preview.style.width = LENS_SIZE + 'px';
    preview.style.height = LENS_SIZE + 'px';
    preview.style.position = 'absolute';
    preview.style.left = '0';
    preview.style.top = '0';
    preview.style.zIndex = '0';
    el.appendChild(preview);

    // text overlay
    const pre = document.createElement('pre');
    pre.textContent = text;
    el.appendChild(pre);

    document.body.appendChild(el);

    // initial draw
    drawLensPreview(preview, sx, sy, sampleSize);

    return { el, preview, pre };
  }

  function removeLens(lens, immediate = false) {
    if (!lens) return;
    if (immediate) {
      lens.remove();
      return;
    }
    lens.style.opacity = '0';
    setTimeout(() => { if (lens.parentNode) lens.remove(); }, 350);
  }

  // show lens only while pointer is down (no permanent lenses)
  let activeLens = null;

  // helper: clamp values
  function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }

  // helper: sample pixel block and return binary text plus source coordinates
  function getSampleInfo(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const cssX = clientX - rect.left;
    const cssY = clientY - rect.top;
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const cx = Math.round(cssX * scaleX);
    const cy = Math.round(cssY * scaleY);

    const size = 12;
    const half = Math.floor(size / 2);

    let sx = cx - half;
    let sy = cy - half;
    sx = clamp(sx, 0, canvas.width - size);
    sy = clamp(sy, 0, canvas.height - size);

    let data;
    try {
      data = ctx.getImageData(sx, sy, size, size).data;
    } catch (err) {
      data = new Uint8ClampedArray(size * size * 4);
    }

    let out = "";
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i+1];
      const b = data[i+2];
      out += r.toString(2).padStart(8, "0") + " " + g.toString(2).padStart(8, "0") + " " + b.toString(2).padStart(8, "0") + "\n";
    }
    return { text: out, sx, sy, size };
  }

  canvas.addEventListener('pointerdown', e => {
    if (e.isPrimary === false) return;
    const info = getSampleInfo(e.clientX, e.clientY);
    activeLens = createLens(e.clientX, e.clientY, info.text, info.sx, info.sy, info.size);

    // while pointer moves, update lens position and sampled content
    const onMove = ev => {
      if (!activeLens) return;
      activeLens.el.style.left = (ev.clientX - LENS_SIZE/2) + 'px';
      activeLens.el.style.top  = (ev.clientY - LENS_SIZE/2) + 'px';
      const info2 = getSampleInfo(ev.clientX, ev.clientY);
      activeLens.pre.textContent = info2.text;
      drawLensPreview(activeLens.preview, info2.sx, info2.sy, info2.size);
    };

    const onUp = ev => {
      if (activeLens) removeLens(activeLens.el);
      activeLens = null;
      window.removeEventListener('pointermove', onMove);
      window.removeEventListener('pointerup', onUp);
      window.removeEventListener('pointercancel', onUp);
    };

    window.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', onUp);
    window.addEventListener('pointercancel', onUp);
  });
</script>

</body>
</html>
